# Median-of-Two-Sorted-Arrays

有序数组(升序)，`X`(`M`个数)和`Y`(`N`个数)，数组合并后为`Z`(`L`个数)，求两个数组合并后的中位数

要求时间复杂度为`O(log (m+n))`

示例

```js
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
```

```js
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
```

### 分析

数组求中位数有两种情况(以下第×位数从1开始算起)

- 若合并后`L`为偶数，那么中位数为`第L/2位数和第(L/2+1)位数的平均值`
    其中L/2后取整
     
- 若合并后为奇数，那么中位数为     `第(L/2+1)位数`

所以，以上找中位数问题就转变成了在两个已排序数组中找第K大(第K位数)的数

### 解决思路(假设是理想状态下)

- 每次分别在X数组中和Y数组中取k/2个值进行比较(加起来正好K个)，下述为了方便，将`k/2-1`用`middle`表示

- 比较`X[middle]`和`Y[middle]`

- 如果`X[middle]<Y[middle]`，意味着`第k位数>=Y[middle]>X[middle]`，
    所以X[middle]和之前的数肯定不会数第k位数，那么我们可以抛弃X数组中middle以及前面部分，
    	
    ```js
    X=X.slice(middle),Y=Y,k=k-middle;
    ```

    重新进行第一步比较
		
- 如果`X[middle]>Y[middle]`，意味着`第k位数>=X[middle]>Y[middle]`，
    那么我们可以抛弃Y数组中middle以及前面部分，
    	
    ```js
    X=X,Y=Y.slice(middle),k=k-middle;
    ```
    
    重新进行第一步比较
		
- 如果`X[middle]==Y[middle]`，意味着X和Y中正在比较的k位数全部<=第k个数。
    所以第k个数就在正在比较的数之中，而因为数组是升序，所以不是`X[middle]`，就是`Y[middle]`
    我们只需要取最终的值为`X[middle]`即可


### 实现步骤(以下数组是从0开始算起的)，考虑到一些可能的实际情况，找数组中第K大的数

- 第一步，我们交换两个数组的位置，确保X大小小于等于Y(如果X已经大于Y，则交换两个数组)

- 第二步，如果X数组为0，那么第k位数肯定在Y中，并且值就是`Y[k-1]`

- 第三步，如果k为1，那么只需要取`Math.min(X[0],Y[0])`，因为第一位数只可能是两个数组中的首位中的最小的一个

- 第四步，如果k不满足以上特殊值，则分别比较X数组和Y数组中特定的值

	```js
	var partA = ~~Math.min(k/2,m),partB = k - partA;
	//这时候X中需要比较的值的分布可能为下述情况(当k/2为1时，则只有一个partA)
	0,...,partA-1
	//Y中需要比较的值得分布可能为
	0,...,partB-1
	//而且X中需要比较的数和Y中需要比较的数加起来刚好有k位，而且(第k位数>=X[partA-1],第k位数>=X[partB-1])
	```
	
	- 如果`X[partA-1]<Y[partB-1]`，(原理上述已经分析)
	
		```
		X=X.slice(partA),Y=Y,k=k-partA;
		```
		重新进行第一步比较

	- 如果`X[partA-1]>Y[partB-1]`，(原理上述已经分析)
	
		```
		X=X,Y=Y.slice(partB),k=k-partB;
		```
		重新进行第一步比较
		
	- 如果`X[partA-1]==Y[partB-1]`，(原理上述已经分析)
	取最终的值为`X[partA-1]`
	
### 算法复杂度

#### 空间复杂度

```js
O(1)
```

这个算法没有额外的空间要求

#### 时间复杂度
这个算法每次分别去掉某一个数组中的某一部分，假设X数组长度为，Y数组长度为N。
那么复杂度计算方式为:

```js
0(lgM+lg(N))=O(lgMN)<=O(2lg(M+N)) = O(lg(M+N))
```

	
### 具体示例分析实现

以下按照上述算法实现步骤，基于一个实例进行分析。

#### 前提

```js
X=[1,3,5];
Y=[1,2,3,4];
```

求X和Y的中间值

#### 准备工作

可知，初始化时X中有3位，Y中有4为，所以一共7位，为奇数。
那么我们所求是第`4=(3+4)/2+1`位数

#### 实现过程

* 第一步，X长度小于Y，不需要交换，其中X数组的长度m为3，Y数组的长度n为4，k为4

* 第二步，取特殊值进行比较

	```js
	var partA = ~~Math.min(k/2,m); //2
	var partB = k - partA; //2
	```
* 第三步，比较`X[partA-1]`和`Y[partB-1]`，结果是`X[1]>Y[1]`，
	所以舍弃Y中部分值，重新进行比较
	
	```js
	X=X,Y=Y.slice(partB),k=k-partB;
	```
	舍弃完毕后，X为`1,3,5`，Y为`3,4`，k为2
	之后交换X和为，X换为`3,4`，m为2，Y换位`1,3,5`，n为3
	
* 第四步，重新去特殊值进行比较

	```js
	var partA = ~~Math.min(k/2,m);//1
	var partB = k - partA; //1
	```
	
* 第五步，比较`X[partA-1]`和`Y[partB-1]`，结果是`X[0]>Y[0]`，
	所以舍弃Y中部分值，重新进行比较
	
	```js
	X=X,Y=Y.slice(partB),k=k-partB;
	```
	舍弃完毕后，X为`3,4`，Y为`3,5`，k为1
	不需要交换x与Y，此时m为2，n为2
	
* 第六步，重新比较新的数组，由于符合条件`k==1`，所以
	
	```js
	第k个值 = Math.min(X[0],Y[0]); //3
	```
	至此，整个算法流程运行完毕，最终的中间值为`3`