## Permutations-II

## 说明
和上一题一样，也是计算全排列，不过不同之处在于，这次给出的元素中，可以有重复值，但是计算出来的全排列不允许重复，例如:

`[1,1,2]`，返回:

```
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

### 思路

* 1.采用字典序的非递归方法。 从字典顺序最小的一种排列开始，每次获得字典序刚好比前一个排列大的排列，
	直到得到字典序最大的排列时，就得到了所有的结果， 以字符串"abc"为例，"abc"是字典序最小的排列，
	所有情况按字典序排列为"abc","acb","bac","bca"，"cba","cab"。
	
	具体步骤为为：
	1.字符串进行排序，得到字符串的最小字典序排列(C0C1C2...Cn)，Ci<=Ci+1。  
	2.从后往前，找到一对相邻的升序元素CiCi+1，(Ci<Ci+1)，如果遍历完字符串找不到这样的相邻升序对，说明已经达到了字典序最大的全排列
	3.从字符串结束位置到位置i遍历，找到比Ci大的元素Cj，交换Cj的位置
	4.将Ci+1到Cn所有的字符逆序，这样得到的排列刚好比之前的字典序大(因为转换后Ci+1<Ci+2<...<Cn，为最小字典序）。
	5.重复3,4,5过程直到字典序最大。
	
	来源:http://blog.csdn.net/u013140542/article/details/38495565
	这个算法也满足前面一个题目的(因为前面一个题目本来就是非重复数字)
